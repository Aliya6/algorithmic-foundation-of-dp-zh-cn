# 查询算法的Boosting

我们将使用第[2](/2-Basic-Terms/Overview.html)节中概述的数据库的*行表示*，其中我们将数据库视为行的多重集或$$\mathcal{X}$$的元素。固定数据库大小$$n$$、数据域$$\mathcal{X}$$和敏感度最大为$$\rho$$的实值查询的查询集$$\mathcal{Q}={q:\mathcal{X}^*→\mathbb{R}}$$。

我们假设存在一个基本大纲生成器（在第[6.2](/6-Boosting-for-Queries/Base-synopsis-generators/A-generalization-bound.html)节中，我们将看到如何构造这些）。接下来，我们需要的基本生成器的性质是，对于查询集$$\mathcal{Q}$$上的任何分布$$\mathcal{D}$$，基本生成器的输出都可以用于计算大部分查询的准确答案，其中 “大分数” 是根据$$\mathcal{D}$$给出的权重定义的。基生成器由$$k$$参数化，即要采样的查询数；$$\lambda$$是输出的精度要求；  η 是对“大”的度量，描述了大部分查询的含义，$$\beta$$是失败概率。

**定义 6.1**（$$(k,\lambda,\eta,\beta)-$$基本大纲生成器）对于固定的数据库大小$n$，数据域$$\mathcal{X}$$和查询集$$\mathcal{Q}$$，考虑大纲生成器$$\mathcal{M}$$，其独立地从$$\mathcal{Q}$$上的分布$$\mathcal{D}$$对$$k$$个查询进行采样并输出大纲。我们称$$\mathcal{M}$$是一个$$(k,\lambda,\eta,\beta)-$$基本大纲生成器，如果对于任何$$\mathcal{Q}$$上的分布$$\mathcal{D}$$，除了$$\beta$$概率之外，所有$$\mathcal{M}$$的硬币翻转，$$\mathcal{M}$$输出的大纲$$\mathcal{S}$$对于由$$\mathcal{D}$$加权的$$\mathcal{Q}$$的$$1/2+\eta$$质量是$$\lambda-$$精确的：
$$
\begin{align}
\underset{q\sim\mathcal{D}}{\text{Pr}}[|q(\mathcal{S})-q(x)|\leq\eta]\geq1/2+\eta.\tag{6.1}
\end{align}
$$
查询增强算法可用于任何类别的查询和任何不同的私有基本大纲生成器。 运行时间继承自基本大纲生成器。Booster在$$|\mathcal{Q}|$$中投入了准线性的额外时间，特别是其运行时间并不直接依赖于数据域的大小。

要指定提升（boosting）算法，我们需要指定停止条件、聚合机制以及用于更新$$\mathcal{Q}$$上的当前分布的算法。

**停止条件.** 我们将固定$$T$$轮运行算法——这将是我们的停止条件。选择$$T$$以保证高的准确度（以极大可能）；正如我们将看到的，只需要$$\log|\mathcal{Q}|/\eta^2$$轮就足够了。

**更新分布.** 尽管分布从未在输出中直接显示，但基本大纲$$\mathcal{A}_1,\mathcal{A}_2,\mathcal{A}_3,...,\mathcal{A}_T$$会被揭示，并且在构造$$\mathcal{A}_i$$时，每个$$\mathcal{A}_i$$在原则上都能从$$\mathcal{D}_i$$上泄露所选查询信息。因此，我们需要限制在相邻数据库上获得的概率分布之间的最大散度。这在技术上是具有挑战性的，因为给定$$\mathcal{A}_i$$，数据库在构建$$\mathcal{D}_{i+1}$$时涉及到的非常多。

初始分布$$\mathcal{D}_1$$在$$\mathcal{Q}$$上是均匀分布的。一个更新$$\mathcal{D}_t$$的标准方法是增加处理不良元素的权重，在我们的情况下，对于$$|q(x)-q(A_t)|>\lambda$$的查询，通过一个固定的因子（增加处理不良元素的权重），比如$$e$$，并通过相同的因子减少处理良好的元素权重。（然后将权重归一化以便总和为 1。）为了困难化，令$$x=y\cup\{\xi\}$$，并假设当数据库是$$y$$时，所有的查询$$q$$都被$$\mathcal{A}_t$$很好的处理，但是加上$$\xi$$后导致处理失败，例如，一个1/10的查询；即，对于所有查询$$q$$，$$|q(y)-	q(\mathcal{A}_t)|\leq\lambda$$，但是对于某些$$|\mathcal{Q}|/10$$的查询，$$|q(y)-	q(\mathcal{A}_t)|\geq\lambda$$。请注意，因为$$\mathcal{A}_t$$甚至在数据库是$$x$$时都有9/10的查询“表现良好”，无论$$x,y$$中的哪一个是真实的数据集，它都可以从基础sanitizer返回。我们关心的是更新的影响：当数据库为$$y$$时，所有查询都得到了很好的处理，并且没有重新加权（规范化之后），但是当数据库为$$x$$时，有一个重新加权：十分之一的查询的权重增加了 ，剩下的十分之九的权重减少了。 这种重新加权的差异可以在下一次迭代中通过$$\mathcal{A}_{t+1}$$检测到，这是可观察的，并且将根据数据库是$$x$$还是$$y$$，从相当不同的分布中抽取样本构建。

例如，假设我们从均匀分布$$\mathcal{D}_1$$开始。那么$$\mathcal{D}_2^{(y)}=\mathcal{D}_1^{(y)}$$，其中$$\mathcal{D}_i^{(z)}$$表示当数据库是$$z$$时的第$$i$$轮分布。这是因为每个查询的权重都减少了一个因子$$e$$，这在归一化中消失了。因此每一个$$q\in\mathcal{Q}$$在$$\mathcal{D}_2^{(y)}$$中被分配了权重$$1/\mathcal{Q}$$。相反，当数据库为$$x$$时，“不满意”的查询具有归一化权重
$$
\frac{\frac{e}{|\mathcal{Q}|}}{\frac{9}{10}\frac{1}{|\mathcal{Q}|}\frac{1}{e}+\frac{1}{10}\frac{e}{|\mathcal{Q}|}}.
$$
考虑任意这样不满意的查询$$q$$。比例$$\mathcal{D}_2^{(x)}(q)/\mathcal{D}_2^{(y)}(q)$$由下式给出
$$
\begin{align}
\frac{\mathcal{D}_2^{(x)}(q)}{\mathcal{D}_2^{(y)}(q)}&=\frac{\frac{\frac{e}{|\mathcal{Q}|}}{\frac{9}{10}\frac{1}{|\mathcal{Q}|}\frac{1}{e}+\frac{1}{10}\frac{e}{|\mathcal{Q}|}}}{\frac{1}{\mathcal{|Q|}}}\\
&=\frac{10}{1+\frac{9}{e^2}}\overset{def}{=}F\approx4.5085.
\end{align}
$$
现在，$$\ln F \approx 1.506$$，即使基本生成器在第2轮中使用的查询选择没有明确公开，它们可能可以从公开的结果$$\mathcal{A}_2$$中检测到。因此，每个查询存在高达1.506的潜在隐私损失（当然，我们期望取消；我们只是试图解释困难的根源）。通过确保基本生成器所使用的样本数量相对较小，可以部分地解决这一问题，尽管我们仍然存在这样的问题，即在多次迭代中，即使在相邻数据库上，分布DT也可能非常不同地演化。
