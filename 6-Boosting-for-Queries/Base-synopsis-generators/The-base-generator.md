# 基础生成器

我们的第一台发电机靠蛮力工作。根据分布 D 独立采样一组 S（包含 k 个查询）后，基本生成器将通过拉普拉斯机制为 S 中的所有查询生成噪声答案。然后，算法不再进一步使用实际数据库，而是搜索这些噪声答案足够接近的大小为 n 的任何数据库，并输出该数据库。隐私将是立即的，因为拉普拉斯机制的 k 次调用之后的所有内容都在后处理中。因此，隐私损失的唯一来源是拉普拉斯机制的这 k 次调用的累积损失，我们知道如何通过组合定理进行分析。实用性将遵循拉普拉斯机制的实用性——这表明我们即使在一个查询上也不太可能出现“非常大”的错误——再加上真实数据库 x 是适合这些噪声响应的 n 元素数据库这一事实。 1

该参数假设数据库的大小 n 已知。或者，我们可以包含“数据库中有多少行？”形式的嘈杂查询。并详尽地搜索大小接近该查询的响应的所有数据库。

定理 6.6（任意查询的基本概要生成器）。对于任何数据域 X 、数据库大小 n 和类 Q : {X ∗ → R} 的敏感度至多为 ρ 的查询，对于任何 εbase，δbase > 0，存在一个 (εbase, δbase)-差分私有 (k, λ, η = 1/3, β)-Q 的基本概要生成器，其中 k = am > 6(m+log(2/β)) = 6(n log |X |+log(2/β)) 且λ > 2b(log k + log(2/β))，其中 b = ρ√am log(1/δbase)/εbase。生成器的运行时间为|X |n·poly(n, log(1/β), log(1/εbase), log(1/δbase))。证明。我们首先在高层次上描述基本生成器，然后确定 k 和 λ 的值。基本生成器生成的概要 y 将是大小为 n 的综合数据库。因此 m = |y| = n·log |X |。生成器首先选择包含 k 个查询的集合 S，根据 D 进行独立采样。它使用拉普拉斯机制计算每个查询 q ∈ S 的噪声答案，为每个真实答案添加从 Lap(b) 中独立抽取的结果，以获得适当的结果。 b 稍后确定。令 { ̂ q(x)}q∈Q 为噪声答案的集合。生成器枚举大小为 n 的所有 |X |n 数据库，并输出按字典顺序排列的第一个数据库 y，这样对于每个 q ∈ S，我们有 |q(y) − ̂ q(x)| ≤ λ/2。如果没有找到这样的数据库，它会输出⊥，我们说它失败了。请注意，如果 | ̂ q(x) − q(x)| < λ/2 和 |q(y) − ̂ q(x)| < λ/2，则 |q(y) − q(x)| < λ。我们的特定发电机有两个潜在的故障来源。一种可能性是 y 无法泛化，或者如引理 6.5 的证明中所定义的那样不好。第二种可能性是拉普拉斯分布的样本之一量级过大，这可能会导致生成器发生故障。我们将选择参数，以便将每个事件的概率分别限制为最多 β/2。代入 η = 1/3 且 m = n log |X|代入公式 6.9 表明，取 a > 6(1 + log(2/β)/m) 足以使因 S 选择而导致的失败概率受 β/2 限制。因此，取 k = am > 6(m + log(2/β)) = 6(n log |X | + log(2/β)) 就足够了。我们有 k 个最多为 ρ 的敏感度查询。使用参数 b = 2√2k log(1/δbase)ρ/εbase 的拉普拉斯机制，确保每次查询最多产生 εbase/√2k ln(1/δbase) 的隐私损失，即

推论 3.21 确保整个过程是 (εbase, δbase) 差分隐私的。我们将选择 λ，以便 Lap(b) 中的任何平局的幅度超过 λ/2 的概率至多为 β/2。条件是所有 k 个绘制的幅度最多为 λ，我们知道输入数据库本身将 λ 适合我们的噪声答案，因此该过程不会失败。回想一下，拉普拉斯分布的浓度特性确保从 Lap(b) 中抽取的概率至少为 1−et，其大小将以 tb 为界。设置 λ/2 = tb，给定平局的幅度超过 λ/2 的概率受到 e−t = e−λ/2b 的限制。为了确保 k 个抽签中没有一个的大小超过 λ/2，通过并集，满足 ke−λ/2b < β/2 ⇔ eλ/2b > k 2 β ⇔ λ/2 > b(log k + log(2/β)) ⇔ λ > 2b(log k + log(2/β))。线性查询的特例。对于线性查询的特殊情况，可以避免对小型数据库进行强力搜索。该技术需要的时间是 (|Q|, |X |, n, log(1/β)) 中的多项式。我们将重点关注计数查询的情况并绘制结构示意图。与任意查询的基本生成器的情况一样，基本生成器首先根据 D 选择一组 S 的 k = am 查询，并使用拉普拉斯噪声计算噪声答案。然后，线性查询的生成器在 S 上运行一个合成器，粗略地说，它将对任何查询集 R 提供良好近似的任何概要转换为合成数据库，在集合 R 上产生类似质量的近似值。合成器的输入将是S 中查询的噪声值，即 R = S。（回想一下，当我们修改数据库的大小时，我们总是根据计数查询的分数版本来思考：“数据库行的哪一部分满足属性 P ？”）

生成的数据库可能非常大，这意味着它可能有很多行。然后，基础生成器仅对合成数据库的行进行二次采样 n′ = (log k log(1/β))/α2，创建一个较小的合成数据库，该数据库的概率至少为 1 − β 相对于大型综合数据库给出的答案。这会产生 m = ((log k log(1/β))/α2) log |X | 位概要，根据泛化引理，选择的概率为 (1 − log(1/β)) k 个查询，在 Q 的 (1/2 + η) 分数（按 D 加权）上得到很好的回答。与任意查询的基本生成器的情况一样，我们要求 k = am > 6 log(1/β) + 6m。取 α2 = (log Q)/n 我们得到 k > 6 log(1/β) + 6 log k log(1/β) log |X | α2 = 6 log(1/β) + 6n log k log(1/β) log |X |日志|Q| 。合成器并不平凡。其性质由以下定理总结。定理6.7。令 X 为数据域，Q 为一组分数计数查询，A 为具有效用 (α, β, 0) 和任意输出的 (ε, δ) 差分私有概要生成器。那么存在一个合成器 A′，它是 (ε, δ) 差分私有的并且具有效用 (3α, β, 0)。 A' 输出一个（可能很大的）合成数据库。其运行时间是A和(|X |, |Q|, 1/α, log(1/β))运行时间的多项式。在我们的例子中，A 是拉普拉斯机制，概要只是一组嘈杂的答案。复合定理表明，对于 (εbase, δbase) 差分私有的 A，拉普拉斯机制的参数应为 ρ/(εbase/√2k log(1/δbase))。对于分数计数查询，灵敏度为 ρ = 1/n。因此，当我们应用该定理时，我们将得到 ( √k log(1/β)/εbase)ρ 阶的 α。这里，ρ是灵敏度。对于计数查询，它是 1，但我们将转向分数计数查询，因此 ρ = 1/n。定理 6.7 的证明草图。运行 A 来获取 R 中所有查询的（差异私有）（分数）计数。然后，我们将使用线性编程来找到一个近似的低权重分数数据库

这些分数计数，如下所述。最后，我们通过对分数计数进行四舍五入，将该分数数据库转换为标准综合数据库。 A 的输出为每个查询 q ∈ Q 生成分数计数。输入数据库 x 永远不会再次访问，因此 A′ 是 (ε, δ) 差分私有的。令 v 为计数结果向量，即 vq 是 A 的输出在查询 q 上给出的小数计数。在概率为 1 − β 的情况下，v 中的所有条目都是 α 精确的。近似这些计数的“分数”数据库 z 的获取方式如下。回想一下数据库的直方图表示，其中对于全域 X 中的每个元素，直方图包含该元素在数据库中的实例数。现在，对于每个 i ∈ X ，我们引入一个变量 ai ≥ 0，它将“计算”小数数据库 z 中 i 出现的（小数）次数。我们将施加约束 Σ i∈X ai = 1。我们将 z 中查询 q 的计数表示为满足 q 的项 i 的计数之和： Σ i∈X s.t。 q(i)=1 ai 我们希望所有这些计数都在 vq 中各个计数的加性 α 精度范围内。将其写成线性不等式，我们得到： (vq − α) Σ i∈X ai ≤ Σ i ∈ X s.t。 q(i)=1 ai ≤ (vq + α) Σ i∈X ai。当计数相对于 vc 中的计数都是 α 精确时，也有可能（概率为 1 − β）它们相对于原始数据库 x 上的真实计数都是 2α 精确。我们编写一个线性程序，每个查询都有两个这样的约束（总共 2|Q| 约束）。 A′ 尝试找到该线性规划的分数解。要看到这样的解存在，请观察数据库 x 本身与计数向量 v​​ α 接近，因此存在线性规划的解（实际上甚至是整数解），因此 A′ 将找到一些分数解。

我们得出结论，A′ 可以生成具有 (2α, β, 0) 效用的分数数据库，但我们确实需要一个合成（整数）数据库。为了将小数数据库转换为整数 1，我们将每个 ai 向下舍入（对于 i ∈ X ）到最接近的 α/|X | 倍数，这会将每个小数计数最多更改 α/|X |加法因子，因此舍入计数具有 (3α, β, 0) 效用。现在我们可以将舍入分数数据库（总权重为 1）视为（多项式）大小最多 |X |/α 的整数合成数据库。回想一下，在定理 6.7 的应用中，我们将 A 定义为使用参数 ρ/(εbase/√2k log(1/δbase)) 添加拉普拉斯噪声的机制。我们进行了 k 次抽签，因此通过取 α′ = ρ √ 2k log(1/δbase)(log k + log(1/β))，我们可以得出 A 的精度为 (α′, β, 0)。对于基本生成器，我们选择误差 α2 = (log |Q|)/n。如果合成器的输出太大，我们进行二次采样 n′ = log |Q| log(1/β) α2 = log k log(1/β) α2 行。以概率 1 − β，结果数据库在所有方面保持 O(ρ√(log |Q|)/n + (√2k log(1/δbase)/εbase)(log k + log(1/β)) 精度最后，如果查询 S ∈ Dk 的选择不能产生良好的泛化，则基本生成器可能会失败，而使用我们选择的参数，这种情况发生的概率最多为 β，从而导致整个生成器的总失败概率。定理 6.8（分数线性查询的基本生成器）对于任何数据域 X 、数据库大小 n 和分数线性查询的类 Q ：{X n → R}（灵敏度至多 1/n）。 εbase, δbase > 0，存在 Q 的 (εbase, δbase) 差分私有 (k, λ, 1/3, 3β) 基概要生成器，其中 k=O ( n log(|X |) log(1 /β) log |Q| ) λ=O ( log(1/β) √n ( √ log |Q| + √ log|X | log|Q| · 1 εbase )) 。

基础生成器的运行时间为poly(|X |, n, log(1/β), log(1/εbase))。这里使用的采样界限与SmallDB机制构建中使用的采样界限相同，但参数不同。在这里，我们在具有非常小的查询集的复杂提升算法中将这些边界用于基本生成器；在那里，我们使用它们一次性生成具有巨大查询集的合成数据库。
