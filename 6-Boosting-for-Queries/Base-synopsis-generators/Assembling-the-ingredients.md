# 要素组装

总误差来自 μ（参见公式 6.2）和 λ（基础生成器的精度参数）的选择。让我们回顾一下定理6.1：定理6.9（定理6.1）。令 Q 为敏感度至多为 ρ 的查询族。对于适当的参数设置，并且 T = log |Q|/η2 轮，图 6.1 的算法是一种准确且差分隐私的查询提升算法： 1. 当用 (k, λ, η, β) 实例化时- 基本概要生成器，Boosting 算法的输出以至少 1 − T β 的概率为 Q 中的所有查询提供 (λ + μ) 准确的答案，其中 μ ∈ O(((log3/2 |Q|) √ k √ log(1/β)ρ)/(εsample·η3))。 (6.10) 2. 如果基本概要生成器是(εbase, δbase)-差分隐私，则boosting 算法是((εsample + T·εbase), T (β + δbase))-差分隐私。根据公式 6.7，εsample def = √ 2kT log(1/β)(α4T​​ ρ/μ) + kT ( α4T ρ μ )2 ，其中 α = (1/2)(ln(1 + 2η)(1 − 2η) ) ∈ O(1)。我们总是有 T = (log |Q|)/η2，因此将该值代入上面的方程，我们可以看到边界 μ ∈ O(((log3/2 |Q|) √ k √ log(1/β)定理陈述中的 ρ)/(εsample · η3)) 是可以接受的。
对于任意查询的情况，当 η 为常数时，我们有 λεO (ρ εbase ( √ n log |X | log(1/δbase)(log(n log |X |) + log(2/β)) ) ) 。现在，εboost = T εbase + εsample。将这两项设置为相等，因此 T εbase = εboost/2 = εsample，因此我们可以用 2T /εboost = (log |Q|/η2)/2εboost 替换 1/εbase 项。现在我们的 λ 和 μ 项具有相似的分母，因为 η 是常数。因此，我们可以得出结论，总误差的界限为： λ+με ̃ O ( √n log |X |ρ log3/2 |Q|(log(1/β))3/2 εboost ) 。通过类似的推理，对于分数计数查询的情况，我们得到 λ+με ̃ O ( √log |X | log |Q| log(1/β)3/2 εboost √n ) 。为了转换为普通非分数计数查询的界限，我们乘以 n 以获得 λ+με ̃ O ( √n log |X | log |Q| log(1/β)3/2 εboost ) 。
