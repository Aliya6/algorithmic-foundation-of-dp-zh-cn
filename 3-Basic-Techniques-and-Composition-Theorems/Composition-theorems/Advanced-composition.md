# 3.5.2 高级组成技术

除了允许参数降级得更慢之外，我们希望我们的定理能够处理更复杂的组成形式。但是，在开始之前，我们必须讨论组成对我们的确切含义。我们希望我们的定义涵盖以下两个有趣的场景：

- 1.在同一数据库上重复使用差分隐私算法。这允许多次重复使用相同的机制，以及从任意私有模块中模块化构造差分私有算法。
- 2.在不同的数据库上重复使用差分隐私算法，这些数据库可能包含与同一个人的有关信息。这使我们能够推断出一个个体的隐私累积损失，其数据可能分布在多个数据集上，每个数据库可能使用不同的差分隐私算法独立运行。由于新数据库一直在创建，并且对手实际上可能会影响这些新数据库的组成，因此与重复查询单个固定数据库相比，这是一个根本不同的问题。

我们希望对组成进行建模，在这些组成中攻击者可以适应性地影响未来机制输入的数据库以及对这些未来机制的查询。令 $\mathcal{F}$ 为一系列数据库访问机制。（例如 $\mathcal{F}$ 可以是所有 $\varepsilon-$差分隐私机制的集合）对于概率对手 $A$，我们考虑两个实验，实验0和实验1定义如下。

**用 Bob 的数据 b 对机制集合 $\mathcal{F}$ 进行实验，对手为 $A$  ：**

$i=1,...,k$

- 1. $A$ 输出两个相邻数据集 $x_i^0,x_i^1$，和机制 $\mathcal{M}_i \in \mathcal{F}$，且参数为 $w_i$。
- 2. $A$ 接收 $y_i \in_{R} \mathcal{M}_i(w_i,x_{i,b})$

我们允许上面的对手A在整个实验中都是有状态的，因此，它可以根据先前机制的输出自适应地选择数据库，机制和参数。我们将A对实验的看法定义为A投掷硬币和所有机制输出 $(y_1,...,y_k)$。（$x_i^j,\mathcal{M}_i,w_i$ 都可以从这些看法中重建。）

出于直观表示，我们假设一个对手总是选择 $x_i^0$ x保存 Bob 的数据，而 $x_i^1$ 与 $x_i^0$ 的区别只有 Bob 的数据在 $x_i^1$ 中被删除。然后实验0可以被认为是“真实世界”，Bob 允许他的数据在许多数据发布中使用；实验1是“理想世界”，这些数据发布的结果不依赖于Bob的数据。就像差分隐私定义所要求的那样，我们对隐私的定义仍然要求这两个实验相互“接近”。对 Bob 的直观保证是，考虑到所有 $k$ 个机制的输出，对手“不知道” Bob 的数据是否被使用了。